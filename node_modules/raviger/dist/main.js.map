{"version":3,"file":"main.js","sources":["../src/context.tsx","../src/node.ts","../src/intercept.ts","../src/location.ts","../src/hooks.ts","../src/typeChecks.ts","../src/router.tsx","../src/navigate.ts","../src/querystring.ts","../src/redirect.ts","../src/Link.tsx"],"sourcesContent":["import React, { createContext, useContext, useMemo } from 'react'\n\nconst BasePathContext = createContext('')\nconst PathContext = createContext<string | null>(null)\n\nexport { BasePathContext }\nexport { PathContext }\n\nexport function useRouter(): { basePath: string; path: string | null } {\n  const [basePath, path] = [useContext(BasePathContext), useContext(PathContext)]\n  return useMemo(() => ({ basePath, path }), [basePath, path])\n}\n\nexport function RouterProvider({\n  basePath = '',\n  path,\n  children,\n}: {\n  basePath?: string\n  path?: string\n  children?: React.ReactNode\n}): JSX.Element {\n  return (\n    // The ordering here is important, the basePath will change less often\n    // So putting it on the outside reduces its need to re-render\n    <BasePathContext.Provider value={basePath}>\n      <PathContext.Provider value={path ?? null}>{children}</PathContext.Provider>\n    </BasePathContext.Provider>\n  )\n}\n","let ssrPath = '/'\nlet isNode = true\ntry {\n  isNode = window === undefined\n} catch (e) {} // eslint-disable-line no-empty\n\nexport { isNode }\nexport function getSsrPath(): string {\n  return ssrPath\n}\nexport function setSsrPath(path: string): void {\n  ssrPath = path\n}\n","const interceptors = new Set<() => string | void>()\n\nexport const defaultPrompt = 'Are you sure you want to leave this page?'\n\nlet hasIntercepted = false\nlet hasUserCancelled = false\nlet lastScroll = [0, 0] as [number, number]\n\nexport function shouldCancelNavigation(): boolean {\n  lastScroll = [window.scrollX, window.scrollY]\n  if (hasIntercepted) return hasUserCancelled\n\n  // confirm if any interceptors return true\n  return Array.from(interceptors).some((interceptor) => {\n    const prompt = interceptor()\n    if (!prompt) return false\n\n    // cancel navigation if user declines\n    hasUserCancelled = !window.confirm(prompt) // eslint-disable-line no-alert\n\n    // track user response so that multiple interceptors don't prompt\n    hasIntercepted = true\n\n    // reset so that future navigation attempts are prompted\n    setTimeout(() => {\n      hasIntercepted = false\n      hasUserCancelled = false\n    }, 0)\n\n    return hasUserCancelled\n  })\n}\n\nexport function addInterceptor(handler: () => string | void): void {\n  window.addEventListener('beforeunload', handler)\n  interceptors.add(handler)\n}\n\nexport function removeInterceptor(handler: () => string | void): void {\n  window.removeEventListener('beforeunload', handler)\n  interceptors.delete(handler)\n}\n\nexport function undoNavigation(lastPath: string): void {\n  window.history.pushState(null, null as unknown as string, lastPath)\n  setTimeout(() => {\n    window.scrollTo(...lastScroll)\n  }, 0)\n}\n","import { useState, useCallback, useRef, useContext, useLayoutEffect } from 'react'\n\nimport { BasePathContext, PathContext } from './context'\nimport { useMountedLayout } from './hooks'\nimport { getSsrPath, isNode } from './node'\nimport { shouldCancelNavigation } from './intercept'\nimport { isFunction } from './typeChecks'\n\nexport interface RavigerLocation {\n  /** The current path; alias of `pathname` */\n  path: string | null\n  /** The current path; alias of `path` */\n  pathname: string | null\n  /** The full path, ignores any `basePath` in the context */\n  fullPath: string\n  basePath?: string\n  search: string\n  hash: string\n  host: string\n  hostname: string\n  href: string\n  origin: string\n}\n\nexport interface RavigerHistory {\n  scrollRestoration: 'auto' | 'manual'\n  state: unknown\n}\n\nexport interface LocationChangeSetFn {\n  (location: RavigerLocation): void\n}\nexport interface LocationChangeOptionParams {\n  inheritBasePath?: boolean\n  basePath?: string\n  isActive?: boolean | (() => boolean)\n  onInitial?: boolean\n}\n\nexport function usePath(basePath?: string): string | null {\n  const contextPath = useContext(PathContext)\n  const contextBasePath = useBasePath() // hooks can't be called conditionally\n  basePath = basePath || contextBasePath\n\n  // Don't bother tracking the actual path, it can get out of sync\n  // due to React parent/child render ordering, especially with onmount navigation\n  // See issues:\n  // https://github.com/kyeotic/raviger/issues/116\n  // https://github.com/kyeotic/raviger/issues/64\n  //\n  // This is just used to force a re-render\n  const [, setPath] = useState(getFormattedPath(basePath))\n  const onChange = useCallback(({ path: newPath }) => setPath(newPath), [])\n  useLocationChange(onChange, {\n    basePath,\n    inheritBasePath: !basePath,\n    // Use on initial to handle to force state updates from on-mount navigation\n    onInitial: true,\n  })\n\n  return contextPath || getFormattedPath(basePath)\n}\n\nexport function useBasePath(): string {\n  return useContext(BasePathContext)\n}\n\nexport function useFullPath(): string {\n  const [path, setPath] = useState<string | null>(getCurrentPath())\n  const onChange = useCallback(({ path: newPath }) => setPath(newPath), [])\n  useLocationChange(onChange, { inheritBasePath: false })\n\n  return path || '/'\n}\n\nexport function useHash({ stripHash = true } = {}): string {\n  const [hash, setHash] = useState(window.location.hash)\n  const handleHash = useCallback(() => {\n    const newHash = window.location.hash\n    if (newHash === hash) return\n    setHash(newHash)\n  }, [setHash, hash])\n\n  useLayoutEffect(() => {\n    window.addEventListener('hashchange', handleHash, false)\n    return () => window.removeEventListener('hashchange', handleHash)\n  }, [handleHash])\n\n  useLocationChange(handleHash)\n  return stripHash ? hash.substring(1) : hash\n}\n\nexport function getCurrentPath(): string {\n  return isNode ? getSsrPath() : window.location.pathname || '/'\n}\n\nexport function getCurrentHash(): string {\n  if (isNode) {\n    const path = getSsrPath()\n    const hashIndex = path.indexOf('#')\n    return path.substring(hashIndex)\n  }\n  return window.location.hash\n}\n\nexport function useLocationChange(\n  setFn: LocationChangeSetFn,\n  {\n    inheritBasePath = true,\n    basePath = '',\n    isActive,\n    onInitial = false,\n  }: LocationChangeOptionParams = {}\n): void {\n  if (isNode) return\n\n  // All hooks after this are conditional, but the runtime can't actually change\n  /* eslint-disable react-hooks/rules-of-hooks */\n\n  const routerBasePath = useBasePath()\n  if (inheritBasePath && routerBasePath) basePath = routerBasePath\n\n  const setRef = useRef<LocationChangeSetFn>(setFn)\n  useLayoutEffect(() => {\n    // setFn could be an in-render declared callback, making it unstable\n    // This is a method of using an often-changing callback from React Hooks\n    // https://reactjs.org/docs/hooks-faq.html#how-to-read-an-often-changing-value-from-usecallback\n    // While not recommended, it is the best current (16.9) available method\n    // For reducing the useEffect cleanup from setFn changing every render\n    setRef.current = setFn\n  })\n\n  const onPopState = useCallback(() => {\n    // No predicate defaults true\n    if (isActive !== undefined && !isPredicateActive(isActive)) return\n    if (shouldCancelNavigation()) return\n    setRef.current(getFormattedLocation(basePath))\n  }, [isActive, basePath])\n\n  useLayoutEffect(() => {\n    window.addEventListener('popstate', onPopState)\n    return () => window.removeEventListener('popstate', onPopState)\n  }, [onPopState])\n\n  // When the basePath changes re-check the path after the render completes\n  // This allows nested contexts to get an up-to-date formatted path\n  useMountedLayout(\n    () => {\n      if (isActive !== undefined && !isPredicateActive(isActive)) return\n      setRef.current(getFormattedLocation(basePath))\n    },\n    [basePath, isActive],\n    { onInitial }\n  )\n}\n\nexport function useHistory(): RavigerHistory {\n  const [history, setHistory] = useState(getRavigerHistory())\n  useLocationChange(useCallback(() => setHistory(getRavigerHistory()), [setHistory]))\n  return history\n}\n\nfunction getRavigerHistory(): RavigerHistory {\n  if (isNode) return { scrollRestoration: 'manual', state: null }\n  return {\n    scrollRestoration: window.history.scrollRestoration,\n    state: window.history.state,\n  }\n}\n\n/**\n * Returns the current path after decoding. If basePath is provided it will be removed from the front of the path.\n * If basePath is provided and the path does not begin with it will return null\n * @param {string} basePath basePath, if any\n * @return {string | null} returns path with basePath prefix removed, or null if basePath is provided and missing\n */\nexport function getFormattedPath(basePath: string): string | null {\n  const path = getCurrentPath()\n  const baseMissing = basePath && !isPathInBase(basePath, path)\n  if (path === null || baseMissing) return null\n  return decodeURIComponent(!basePath ? path : path.replace(basePathMatcher(basePath), '') || '/')\n}\n\nfunction getFormattedLocation(basePath: string): RavigerLocation {\n  const path = getFormattedPath(basePath)\n  return {\n    basePath,\n    path,\n    pathname: path,\n    fullPath: getCurrentPath(),\n    search: window.location.search,\n    hash: getCurrentHash(),\n    host: window.location.host,\n    hostname: window.location.hostname,\n    href: window.location.href,\n    origin: window.location.origin,\n  }\n}\n\nfunction isPredicateActive(predicate: boolean | (() => boolean)): boolean {\n  return isFunction(predicate) ? predicate() : predicate\n}\n\nfunction basePathMatcher(basePath: string): RegExp {\n  return new RegExp('^' + basePath, 'i')\n}\n\nfunction isPathInBase(basePath: string, path: string): boolean {\n  return !!(basePath && path && path.toLowerCase().startsWith(basePath.toLowerCase()))\n}\n","import { useLayoutEffect, useRef } from 'react'\n\nexport function useMountedLayout(\n  fn: () => unknown,\n  deps: React.DependencyList | undefined,\n  { onInitial = false } = {}\n): void {\n  const hasMounted = useRef(onInitial)\n  useLayoutEffect(() => {\n    if (!hasMounted.current) hasMounted.current = true\n    else fn()\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, deps)\n}\n","// eslint-disable-next-line @typescript-eslint/ban-types, @typescript-eslint/explicit-module-boundary-types\nexport function isFunction(obj: unknown): obj is Function {\n  return !!obj && typeof obj === 'function'\n}\n","import React, { useCallback, useLayoutEffect, useMemo, useState } from 'react'\n\nimport { RouterProvider } from './context'\nimport { isNode, setSsrPath, getSsrPath } from './node'\nimport { getFormattedPath, usePath } from './location'\nimport type { NonEmptyRecord, Split, ValueOf } from './types'\n\nconst emptyPathResult: [null, null] = [null, null]\n\nexport interface PathParamOptions {\n  basePath?: string\n  matchTrailingSlash?: boolean\n}\nexport interface RouteOptionParams extends PathParamOptions {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  routeProps?: { [k: string]: any }\n  overridePathParams?: boolean\n}\ninterface RouteMatcher {\n  path: string\n  regex: RegExp\n  props: string[]\n}\n\ntype ExtractPathParams<Path extends string, Parts = Split<Path, '/'>> = Parts extends [\n  infer Head,\n  ...infer Tail\n]\n  ? Head extends `:${infer Name}`\n    ? { [N in Name]: string } & ExtractPathParams<Path, Tail>\n    : ExtractPathParams<Path, Tail>\n  : unknown\n\nexport type Routes<Path extends string> = {\n  [P in Path]: (\n    params: NonEmptyRecord<ExtractPathParams<P extends `${infer P1}*` ? P1 : P>>\n  ) => JSX.Element\n}\n\nexport function useRoutes<Path extends string>(\n  routes: Routes<Path>,\n  {\n    basePath = '',\n    routeProps = {},\n    overridePathParams = true,\n    matchTrailingSlash = true,\n  }: RouteOptionParams = {}\n): JSX.Element | null {\n  /*\n    This is a hack to setup a listener for the path while always using this latest path\n    The issue with usePath is that, in order to not re-render nested components when\n    their parent router changes the path, it uses the context's path\n    But since that path has to get _set_ here in useRoutes something has to give\n    If usePath returns latest it causes render thrashing\n    If useRoutes hacks itself into the latest path nothing bad happens (...afaik)\n  */\n  const path = usePath(basePath) && getFormattedPath(basePath)\n\n  // Handle potential <Redirect /> use in routes\n  useRedirectDetection(basePath, usePath(basePath))\n\n  // Get the current route\n  const route = useMatchRoute(routes, path, {\n    routeProps,\n    overridePathParams,\n    matchTrailingSlash,\n  })\n\n  // No match should not return an empty Provider, just null\n  if (!route || path === null) return null\n  return (\n    <RouterProvider basePath={basePath} path={path}>\n      {route}\n    </RouterProvider>\n  )\n}\n\nfunction useMatchRoute(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  routes: { [key: string]: (...props: any) => JSX.Element },\n  path: string | null,\n  {\n    routeProps,\n    overridePathParams,\n    matchTrailingSlash,\n  }: Omit<RouteOptionParams, 'basePath' | 'matchTrailingSlash'> & { matchTrailingSlash: boolean }\n) {\n  path = trailingMatch(path, matchTrailingSlash)\n  const matchers = useMatchers(Object.keys(routes))\n\n  if (path === null) return null\n  const [routeMatch, props] = getMatchParams(path, matchers)\n\n  if (!routeMatch) return null\n\n  return routes[routeMatch.path](\n    overridePathParams ? { ...props, ...routeProps } : { ...routeProps, ...props }\n  )\n}\n\nexport function usePathParams<Path extends string>(\n  route: Path,\n  options?: PathParamOptions\n): NonEmptyRecord<ExtractPathParams<Path extends `${infer P1}*` ? P1 : Path>> | null\nexport function usePathParams<Path extends string>(\n  routes: ReadonlyArray<Path>,\n  options?: PathParamOptions\n):\n  | ValueOf<{\n      [P in (typeof routes)[number]]: [\n        P,\n        NonEmptyRecord<ExtractPathParams<P extends `${infer P1}*` ? P1 : P>>\n      ]\n    }>\n  | [null, null]\nexport function usePathParams<Params extends ReadonlyArray<string> | string>(\n  routes: Params,\n  options: PathParamOptions = {}\n): Params extends ReadonlyArray<string>\n  ?\n      | ValueOf<{\n          [P in (typeof routes)[number]]: [\n            P,\n            NonEmptyRecord<ExtractPathParams<P extends `${infer P1}*` ? P1 : P>>\n          ]\n        }>\n      | [null, null]\n  : Params extends string\n  ? NonEmptyRecord<ExtractPathParams<Params extends `${infer P1}*` ? P1 : Params>> | null\n  : never {\n  const isSingle = !Array.isArray(routes)\n  const [path, matchers] = usePathOptions(routes as string | string[], options)\n\n  // @ts-expect-error inference is not carried forward and I don't know how to resolve this type\n  if (path === null) return isSingle ? null : emptyPathResult\n\n  const [routeMatch, props] = getMatchParams(path, matchers)\n  // @ts-expect-error inference is not carried forward and I don't know how to resolve this type\n  if (!routeMatch) return isSingle ? null : emptyPathResult\n\n  // @ts-expect-error inference is not carried forward and I don't know how to resolve this type\n  return isSingle\n    ? props\n    : ([routeMatch.path, props] as ValueOf<{\n        [P in (typeof routes)[number]]: [\n          P,\n          NonEmptyRecord<ExtractPathParams<P extends `${infer P1}*` ? P1 : P>>\n        ]\n      }>)\n}\n\nexport function useMatch(routes: string | string[], options: PathParamOptions = {}): string | null {\n  const [path, matchers] = usePathOptions(routes, options)\n  const match = matchers.find(({ regex }) => path?.match(regex))\n\n  return match?.path ?? null\n}\n\nfunction usePathOptions(\n  routeOrRoutes: string | string[],\n  { basePath, matchTrailingSlash = true }: PathParamOptions\n): [string | null, RouteMatcher[]] {\n  const routes = (!Array.isArray(routeOrRoutes) ? [routeOrRoutes] : routeOrRoutes) as string[]\n  const matchers = useMatchers(routes)\n\n  return [trailingMatch(usePath(basePath), matchTrailingSlash), matchers]\n}\n\nfunction useMatchers(routes: string[]): RouteMatcher[] {\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  return useMemo(() => routes.map(createRouteMatcher), [hashParams(routes)])\n}\n\nfunction getMatchParams(\n  path: string,\n  routeMatchers: RouteMatcher[]\n): [RouteMatcher, Record<string, unknown>] | [null, null] {\n  let pathParams: RegExpMatchArray | null = null\n\n  // Hacky method for find + map\n  const routeMatch = routeMatchers.find(({ regex }) => {\n    pathParams = path.match(regex)\n    return !!pathParams\n  })\n\n  if (!routeMatch || pathParams === null) return emptyPathResult\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const props = routeMatch.props.reduce((props: any, prop, i) => {\n    // The following `match` can't be null because the above return asserts it\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    props[prop] = pathParams![i + 1]\n    return props\n  }, {})\n\n  return [routeMatch, props]\n}\n\nfunction createRouteMatcher(path: string): RouteMatcher {\n  return {\n    path,\n    regex: new RegExp(\n      `${path.substr(0, 1) === '*' ? '' : '^'}${escapeRegExp(path)\n        .replace(/:[a-zA-Z]+/g, '([^/]+)')\n        .replace(/\\*/g, '')}${path.substr(-1) === '*' ? '' : '$'}`,\n      'i'\n    ),\n    props: (path.match(/:[a-zA-Z]+/g) ?? []).map((paramName) => paramName.substr(1)),\n  }\n}\n\nexport function setPath(path: string): void {\n  if (!isNode) {\n    throw new Error('This method should only be used in NodeJS environments')\n  }\n  // eslint-disable-next-line @typescript-eslint/no-var-requires\n  const url = require('url')\n  setSsrPath(url.resolve(getSsrPath(), path))\n}\n\n// React doesn't like when the hook dependency array changes size\n// >> Warning: The final argument passed to useMemo changed size between renders. The order and size of this array must remain constant.\n// It is recommended to use a hashing function to produce a single, stable value\n// https://github.com/facebook/react/issues/14324#issuecomment-441489421\nfunction hashParams(params: string[]): string {\n  return [...params].sort().join(':')\n}\n\n// React appears to suppress parent's re-rendering when a child's\n// useLayoutEffect updates internal state\n// the `navigate` call in useRedirect *does* cause usePath/useLocationChange\n// to fire, but without this hack useRoutes suppresses the update\n// TODO: find a better way to cause a synchronous update from useRoutes\nfunction useRedirectDetection(basePath: string, path: string | null) {\n  const [, updateState] = useState({})\n  const forceRender = useCallback(() => updateState({}), [])\n\n  useLayoutEffect(() => {\n    if (path !== getFormattedPath(basePath)) {\n      forceRender()\n    }\n  }, [forceRender, basePath, path])\n}\n\nfunction trailingMatch(path: string | null, matchTrailingSlash: boolean): string | null {\n  if (path === null) return path\n  // path.length > 1 ensure we still match on the root route \"/\" when matchTrailingSlash is set\n  if (matchTrailingSlash && path && path[path.length - 1] === '/' && path.length > 1) {\n    path = path.substring(0, path.length - 1)\n  }\n  return path\n}\n\n// Taken from: https://stackoverflow.com/a/3561711\n// modified to NOT ESCAPE \"/\" and \"*\" since we use those as path parts\nfunction escapeRegExp(string: string): string {\n  return string.replace(/[-\\\\^$+?.()|[\\]{}]/g, '\\\\$&')\n}\n","import { useCallback, useLayoutEffect } from 'react'\n\nimport { useBasePath } from './location'\nimport { isNode } from './node'\nimport type { QueryParam } from './querystring'\nimport {\n  shouldCancelNavigation,\n  addInterceptor,\n  removeInterceptor,\n  defaultPrompt,\n  undoNavigation,\n} from './intercept'\n\nexport interface NavigateOptions {\n  /**\n   * Use a `replace` instead of `push` for navigation\n   * @default false */\n  replace?: boolean\n  /** Values to serialize as a querystring, which will be appended to the `url` */\n  query?: QueryParam | URLSearchParams\n  /**  value to pass as the state/data to history push/replace*/\n  state?: unknown\n}\n\nlet lastPath = ''\n\nexport function navigate(url: string, options?: NavigateOptions): void {\n  if (typeof url !== 'string') {\n    throw new Error(`\"url\" must be a string, was provided a(n) ${typeof url}`)\n  }\n\n  if (Array.isArray(options?.query)) {\n    throw new Error('\"query\" a serializable object or URLSearchParams')\n  }\n\n  if (shouldCancelNavigation()) return\n  if (options?.query) {\n    url += '?' + new URLSearchParams(options.query).toString()\n  }\n\n  lastPath = url\n  // if the origin does not match history navigation will fail with\n  // \"cannot be created in a document with origin\"\n  // When navigating to another domain we must use location instead of history\n  if (isAbsolute(url) && !isCurrentOrigin(url)) {\n    window.location.assign(url)\n    return\n  }\n\n  if (options?.replace) window.history.replaceState(options?.state, '', url)\n  else window.history.pushState(options?.state, '', url)\n\n  const event = new PopStateEvent('popstate')\n  // Tag the event so navigation can be filtered out from browser events\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ;(event as any).__tag = 'raviger:navigation'\n  dispatchEvent(event)\n}\n\nexport function useNavigationPrompt(predicate = true, prompt: string = defaultPrompt): void {\n  if (isNode) return\n\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  useLayoutEffect(() => {\n    const onPopStateNavigation = () => {\n      if (shouldCancelNavigation()) {\n        undoNavigation(lastPath)\n      }\n    }\n    window.addEventListener('popstate', onPopStateNavigation)\n    return () => window.removeEventListener('popstate', onPopStateNavigation)\n  }, [])\n\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  useLayoutEffect(() => {\n    const handler = (e?: BeforeUnloadEvent): string | void => {\n      if (predicate) {\n        return e ? cancelNavigation(e, prompt) : prompt\n      }\n    }\n    addInterceptor(handler)\n    return () => removeInterceptor(handler)\n  }, [predicate, prompt])\n}\n\nfunction cancelNavigation(event: BeforeUnloadEvent, prompt: string) {\n  // Cancel the event as stated by the standard.\n  event.preventDefault()\n  // Chrome requires returnValue to be set.\n  event.returnValue = prompt\n  // Return value for prompt per spec\n  return prompt\n}\n\nexport function useNavigate(optBasePath = ''): typeof navigate {\n  const basePath = useBasePath()\n  const navigateWithBasePath = useCallback<typeof navigate>(\n    (url: string, options?: NavigateOptions) => {\n      const base = optBasePath || basePath\n      const href = url.startsWith('/') ? base + url : url\n      navigate(href, options)\n    },\n    [basePath, optBasePath]\n  )\n  return navigateWithBasePath\n}\n\nfunction isAbsolute(url: string) {\n  return /^(?:[a-z]+:)?\\/\\//i.test(url)\n}\n\nfunction isCurrentOrigin(url: string) {\n  return window.location.origin === new URL(url).origin\n}\n","import { useState, useCallback } from 'react'\n\nimport { navigate } from './navigate'\nimport { isNode, getSsrPath } from './node'\nimport { getCurrentPath, getCurrentHash, useLocationChange } from './location'\n\nexport interface QueryParam {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [key: string]: any\n}\n\nexport interface setQueryParamsOptions {\n  replace?: boolean\n  historyReplace?: boolean\n}\n\nexport function useQueryParams<T extends QueryParam>(\n  parseFn: (query: string) => T = parseQuery,\n  serializeFn: (query: Partial<T>) => string = serializeQuery\n): [T, (query: T, options?: setQueryParamsOptions) => void] {\n  const [querystring, setQuerystring] = useState(getQueryString())\n  const setQueryParams = useCallback(\n    (params, { replace = true, historyReplace = false } = {}) => {\n      let path = getCurrentPath()\n      params = replace ? params : { ...parseFn(querystring), ...params }\n      const serialized = serializeFn(params).toString()\n\n      if (serialized) path += '?' + serialized\n      if (!replace) path += getCurrentHash()\n\n      navigate(path, { replace: historyReplace })\n    },\n    [querystring, parseFn, serializeFn]\n  )\n\n  // Update state when route changes\n  const updateQuery = useCallback(() => setQuerystring(getQueryString()), [])\n\n  useLocationChange(updateQuery)\n  return [parseFn(querystring), setQueryParams]\n}\n\nfunction parseQuery<T extends QueryParam>(querystring: string): T {\n  const q = new URLSearchParams(querystring)\n  return Object.fromEntries(q.entries()) as T\n}\n\nfunction serializeQuery<T extends QueryParam>(queryParams: T): string {\n  return new URLSearchParams(Object.entries(queryParams).filter(([, v]) => v !== null)).toString()\n}\n\nexport function getQueryString(): string {\n  if (isNode) {\n    const ssrPath = getSsrPath()\n    const queryIndex = ssrPath.indexOf('?')\n    return queryIndex === -1 ? '' : ssrPath.substring(queryIndex + 1)\n  }\n  return window.location.search\n}\n","import { useLayoutEffect } from 'react'\n\nimport { getCurrentHash, usePath } from './location'\nimport { navigate } from './navigate'\nimport { QueryParam, useQueryParams } from './querystring'\n\nexport interface RedirectProps {\n  to: string\n  query?: QueryParam | URLSearchParams\n  replace?: boolean\n  merge?: boolean\n}\n\nexport interface UseRedirectProps {\n  predicateUrl: string\n  targetUrl: string\n  queryParams?: QueryParam | URLSearchParams\n  replace?: boolean\n}\n\nexport function Redirect({\n  to,\n  query,\n  replace = true,\n  merge = true,\n}: RedirectProps): JSX.Element | null {\n  useRedirect(usePath(), to, { query, replace, merge })\n  return null\n}\n\nexport function useRedirect(\n  predicateUrl: string | null,\n  targetUrl: string,\n  {\n    query,\n    replace = true,\n    merge = true,\n  }: { query?: QueryParam; replace?: boolean; merge?: boolean } = {}\n): void {\n  const currentPath = usePath()\n  const [currentQuery] = useQueryParams()\n  const hash = getCurrentHash()\n\n  let url = targetUrl\n  const targetQuery = new URLSearchParams({\n    ...(merge ? currentQuery : {}),\n    ...query,\n  }).toString()\n  if (targetQuery) {\n    url += '?' + targetQuery\n  }\n  if (merge && hash && hash.length) {\n    url += hash\n  }\n\n  useLayoutEffect(() => {\n    if (currentPath === predicateUrl) {\n      navigate(url, { replace })\n    }\n  }, [predicateUrl, url, replace, currentPath])\n}\n","import React, { useCallback, forwardRef, Ref } from 'react'\n\nimport { navigate } from './navigate'\nimport { useBasePath, useFullPath } from './location'\n\nexport interface LinkProps extends React.AnchorHTMLAttributes<HTMLAnchorElement> {\n  href: string\n  basePath?: string\n  children?: React.ReactNode\n}\nexport type LinkRef = HTMLAnchorElement | null\n\nexport interface ActiveLinkProps extends LinkProps {\n  activeClass?: string\n  exactActiveClass?: string\n}\n\nfunction Link({ href, basePath, ...props }: LinkProps, ref?: Ref<HTMLAnchorElement>) {\n  basePath = useLinkBasePath(basePath)\n  href = getLinkHref(href, basePath)\n\n  const { onClick, target } = props\n\n  const handleClick = useCallback<React.MouseEventHandler<HTMLAnchorElement>>(\n    (e) => {\n      try {\n        if (onClick) onClick(e)\n      } catch (ex) {\n        e.preventDefault()\n        throw ex\n      }\n      if (shouldTrap(e, target)) {\n        e.preventDefault() // prevent the link from actually navigating\n        navigate(e.currentTarget.href)\n      }\n    },\n    [onClick, target]\n  )\n\n  return <a {...props} href={href} onClick={handleClick} ref={ref} />\n}\n\nconst RefLink = forwardRef<LinkRef, LinkProps>(Link) as (\n  props: LinkProps & { ref?: React.ForwardedRef<HTMLAnchorElement> }\n) => ReturnType<typeof Link>\n\nexport default RefLink\nexport { RefLink as Link }\n\nfunction ActiveLink(\n  { basePath, className, exactActiveClass, activeClass, ...props }: ActiveLinkProps,\n  ref?: Ref<HTMLAnchorElement>\n) {\n  basePath = useLinkBasePath(basePath)\n  const fullPath = useFullPath()\n\n  let { href } = props\n  href = absolutePathName(getLinkHref(href, basePath))\n\n  if (exactActiveClass && fullPath === href)\n    className = `${className ?? ``} ${exactActiveClass}`.trim()\n  if (activeClass && fullPath.startsWith(href))\n    className = `${className ?? ``} ${activeClass}`.trim()\n\n  return <RefLink {...props} basePath={basePath} className={className} ref={ref} />\n}\n\nconst ActiveLinkRef = forwardRef<LinkRef, ActiveLinkProps>(ActiveLink) as (\n  props: ActiveLinkProps & { ref?: React.ForwardedRef<HTMLAnchorElement> }\n) => ReturnType<typeof ActiveLink>\n\nexport { ActiveLinkRef as ActiveLink }\n\nfunction useLinkBasePath(basePath?: string): string {\n  const contextBasePath = useBasePath()\n  if (basePath === '/') return ''\n  return basePath || contextBasePath\n}\n\nfunction getLinkHref(href: string, basePath = '') {\n  return href.startsWith('/') ? basePath + href : href\n}\n\nfunction absolutePathName(href: string): string {\n  if (href.startsWith('/')) return href\n  return new URL(href, document.baseURI).pathname\n}\n\nfunction shouldTrap(e: React.MouseEvent<HTMLAnchorElement, MouseEvent>, target?: string) {\n  return (\n    !e.defaultPrevented && // onClick prevented default\n    e.button === 0 && // ignore everything but left clicks\n    !(target || target === '_self') && // don't trap target === blank\n    !(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)\n  )\n}\n"],"names":["BasePathContext","createContext","PathContext","RouterProvider","basePath","path","children","React","createElement","Provider","value","isNode","undefined","window","e","interceptors","Set","hasIntercepted","hasUserCancelled","lastScroll","shouldCancelNavigation","scrollX","scrollY","Array","from","some","interceptor","prompt","confirm","setTimeout","usePath","contextPath","useContext","contextBasePath","useBasePath","setPath","useState","getFormattedPath","useLocationChange","useCallback","newPath","inheritBasePath","onInitial","useFullPath","getCurrentPath","location","pathname","getCurrentHash","hashIndex","indexOf","substring","hash","setFn","isActive","routerBasePath","setRef","useRef","useLayoutEffect","current","onPopState","isPredicateActive","getFormattedLocation","addEventListener","removeEventListener","useMountedLayout","fn","deps","hasMounted","getRavigerHistory","scrollRestoration","state","history","baseMissing","isPathInBase","toLowerCase","startsWith","decodeURIComponent","replace","basePathMatcher","RegExp","fullPath","search","host","hostname","href","origin","predicate","isFunction","obj","emptyPathResult","usePathOptions","routeOrRoutes","matchTrailingSlash","matchers","useMatchers","isArray","trailingMatch","routes","useMemo","map","createRouteMatcher","params","sort","join","getMatchParams","routeMatchers","pathParams","routeMatch","find","regex","match","props","reduce","prop","i","string","substr","_a","paramName","length","lastPath","navigate","url","options","Error","query","URLSearchParams","toString","isAbsolute","test","isCurrentOrigin","URL","assign","replaceState","pushState","event","PopStateEvent","__tag","dispatchEvent","useQueryParams","parseFn","parseQuery","serializeFn","serializeQuery","querystring","setQuerystring","getQueryString","setQueryParams","historyReplace","serialized","q","Object","fromEntries","entries","queryParams","filter","v","ssrPath","queryIndex","useRedirect","predicateUrl","targetUrl","merge","currentPath","currentQuery","targetQuery","RefLink","forwardRef","Link","ref","getLinkHref","useLinkBasePath","onClick","target","handleClick","ex","preventDefault","shouldTrap","defaultPrevented","button","metaKey","altKey","ctrlKey","shiftKey","currentTarget","ActiveLinkRef","ActiveLink","className","exactActiveClass","activeClass","absolutePathName","document","baseURI","trim","Redirect","to","useHash","stripHash","setHash","handleHash","newHash","useHistory","setHistory","useMatch","useNavigate","optBasePath","base","useNavigationPrompt","onPopStateNavigation","undoNavigation","scrollTo","handler","cancelNavigation","returnValue","addInterceptor","add","removeInterceptor","delete","usePathParams","isSingle","useRoutes","routeProps","overridePathParams","useRedirectDetection","updateState","forceRender","route","useMatchRoute","keys"],"mappings":"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"}